!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CONSOLE_BEGIN	lib.h	51;"	d
CONSOLE_END	lib.h	52;"	d
CR0_AM	x86.h	110;"	d
CR0_CD	x86.h	112;"	d
CR0_EM	x86.h	105;"	d
CR0_ET	x86.h	107;"	d
CR0_MP	x86.h	104;"	d
CR0_NE	x86.h	108;"	d
CR0_NW	x86.h	111;"	d
CR0_PE	x86.h	103;"	d
CR0_PG	x86.h	113;"	d
CR0_TS	x86.h	106;"	d
CR0_WP	x86.h	109;"	d
DECLARE_X86_FUNCTION	x86.h	65;"	d
EFLAGS_AC	x86.h	133;"	d
EFLAGS_AF	x86.h	118;"	d
EFLAGS_CF	x86.h	116;"	d
EFLAGS_DF	x86.h	123;"	d
EFLAGS_ID	x86.h	136;"	d
EFLAGS_IF	x86.h	122;"	d
EFLAGS_IOPL_0	x86.h	126;"	d
EFLAGS_IOPL_1	x86.h	127;"	d
EFLAGS_IOPL_2	x86.h	128;"	d
EFLAGS_IOPL_3	x86.h	129;"	d
EFLAGS_IOPL_MASK	x86.h	125;"	d
EFLAGS_NT	x86.h	130;"	d
EFLAGS_OF	x86.h	124;"	d
EFLAGS_PF	x86.h	117;"	d
EFLAGS_RF	x86.h	131;"	d
EFLAGS_SF	x86.h	120;"	d
EFLAGS_TF	x86.h	121;"	d
EFLAGS_VIF	x86.h	134;"	d
EFLAGS_VIP	x86.h	135;"	d
EFLAGS_VM	x86.h	132;"	d
EFLAGS_ZF	x86.h	119;"	d
ELFHDR	mpos-boot.c	48;"	d	file:
ELF_MAGIC	elf.h	4;"	d
ELF_PROG_FLAG_EXEC	elf.h	52;"	d
ELF_PROG_FLAG_READ	elf.h	54;"	d
ELF_PROG_FLAG_WRITE	elf.h	53;"	d
ELF_PROG_LOAD	elf.h	49;"	d
ELF_SHN_UNDEF	elf.h	63;"	d
ELF_SHT_NULL	elf.h	57;"	d
ELF_SHT_PROGBITS	elf.h	58;"	d
ELF_SHT_STRTAB	elf.h	60;"	d
ELF_SHT_SYMTAB	elf.h	59;"	d
Elf	elf.h	/^struct Elf {$/;"	s
FLAG_ALT	lib.c	104;"	d	file:
FLAG_LEFTJUSTIFY	lib.c	106;"	d	file:
FLAG_PLUSPOSITIVE	lib.c	108;"	d	file:
FLAG_SPACEPOSITIVE	lib.c	107;"	d	file:
FLAG_ZERO	lib.c	105;"	d	file:
INT_SYS_EXIT	mpos.h	11;"	d
INT_SYS_FORK	mpos.h	9;"	d
INT_SYS_GETPID	mpos.h	8;"	d
INT_SYS_USER1	mpos.h	17;"	d
INT_SYS_USER2	mpos.h	18;"	d
INT_SYS_USER3	mpos.h	19;"	d
INT_SYS_USER4	mpos.h	20;"	d
INT_SYS_USER5	mpos.h	21;"	d
INT_SYS_WAIT	mpos.h	12;"	d
INT_SYS_YIELD	mpos.h	10;"	d
KBDATAP	mpos-x86.c	170;"	d	file:
KBSTATP	mpos-x86.c	168;"	d	file:
KBS_DIB	mpos-x86.c	169;"	d	file:
KERNEL_STACK_TOP	mpos-kern.h	30;"	d
MAX	types.h	55;"	d
MIN	types.h	49;"	d
MPOS_BIN_FILES	GNUmakefile	/^MPOS_BIN_FILES = $(OBJDIR)\/mpos-app $(OBJDIR)\/mpos-app2$/;"	m
MPOS_KERN_FILES	GNUmakefile	/^MPOS_KERN_FILES = $(OBJDIR)\/mpos-int.o $(OBJDIR)\/mpos-kern.o \\$/;"	m
NPROCS	mpos.h	26;"	d
NULL	types.h	6;"	d
NUMBUFSIZ	lib.c	115;"	d	file:
PAGESIZE	mpos-boot.c	47;"	d	file:
PAGESIZE	mpos-loader.c	16;"	d	file:
PROC1_STACK_ADDR	mpos-kern.c	21;"	d	file:
PROC_STACK_SIZE	mpos-kern.c	22;"	d	file:
P_BLOCKED	mpos-kern.h	/^	P_BLOCKED,			\/\/ This process is blocked$/;"	e	enum:procstate
P_EMPTY	mpos-kern.h	/^	P_EMPTY = 0,			\/\/ The process table entry is empty$/;"	e	enum:procstate
P_RUNNABLE	mpos-kern.h	/^	P_RUNNABLE,			\/\/ This process is runnable$/;"	e	enum:procstate
P_ZOMBIE	mpos-kern.h	/^	P_ZOMBIE			\/\/ This process has exited, but no one$/;"	e	enum:procstate
Proghdr	elf.h	/^struct Proghdr {$/;"	s
ROUNDDOWN	types.h	64;"	d
ROUNDUP	types.h	70;"	d
SECTORSIZE	mpos-boot.c	46;"	d	file:
SECTORSIZE	mpos-loader.c	15;"	d	file:
SEG	bootstart.S	/^#define SEG(type,base,lim)						\\$/;"	d
SEG	x86.h	492;"	d
SEG16	x86.h	501;"	d
SEGSEL_APP_CODE	mpos-x86.c	42;"	d	file:
SEGSEL_APP_DATA	mpos-x86.c	43;"	d	file:
SEGSEL_KERN_CODE	mpos-x86.c	40;"	d	file:
SEGSEL_KERN_DATA	mpos-x86.c	41;"	d	file:
SEGSEL_TASKSTATE	mpos-x86.c	44;"	d	file:
SEG_FAULT	x86.h	488;"	d
SEG_NULL	bootstart.S	/^#define SEG_NULL							\\$/;"	d
SEG_NULL	x86.h	484;"	d
SETGATE	x86.h	404;"	d
STA_A	x86.h	515;"	d
STA_C	x86.h	512;"	d
STA_E	x86.h	511;"	d
STA_R	bootstart.S	/^#define STA_R	0x2	    \/\/ Readable (executable segments)$/;"	d
STA_R	x86.h	514;"	d
STA_W	bootstart.S	/^#define STA_W	0x2	    \/\/ Writeable (non-executable segments)$/;"	d
STA_W	x86.h	513;"	d
STA_X	bootstart.S	/^#define STA_X	0x8	    \/\/ Executable segment$/;"	d
STA_X	x86.h	510;"	d
STS_CG16	x86.h	521;"	d
STS_CG32	x86.h	527;"	d
STS_IG16	x86.h	523;"	d
STS_IG32	x86.h	528;"	d
STS_LDT	x86.h	519;"	d
STS_T16A	x86.h	518;"	d
STS_T16B	x86.h	520;"	d
STS_T32A	x86.h	525;"	d
STS_T32B	x86.h	526;"	d
STS_TG	x86.h	522;"	d
STS_TG16	x86.h	524;"	d
STS_TG32	x86.h	529;"	d
Secthdr	elf.h	/^struct Secthdr {$/;"	s
V	GNUmakefile	/^V = 0$/;"	m
VV	GNUmakefile	/^VV = @$/;"	m
VV	GNUmakefile	/^VV =$/;"	m
WAIT_TRYAGAIN	mpos.h	31;"	d
WEENSYOS_ELF_H	elf.h	2;"	d
WEENSYOS_LIB_H	lib.h	2;"	d
WEENSYOS_MPOS_APP_H	mpos-app.h	2;"	d
WEENSYOS_MPOS_H	mpos.h	2;"	d
WEENSYOS_MPOS_KERN_H	mpos-kern.h	2;"	d
WEENSYOS_TYPES_H	types.h	2;"	d
WEENSYOS_X86_H	x86.h	2;"	d
__va_size	lib.h	22;"	d
_generic_int_handler	mpos-int.S	/^_generic_int_handler:$/;"	l
app_printf	mpos-app.h	/^app_printf(const char *format, ...)$/;"	f
begin	mpos-loader.c	/^	void *begin;$/;"	m	struct:ramimage	file:
bool_t	types.h	/^typedef int bool_t;$/;"	t
bootmain	mpos-boot.c	/^bootmain(void)$/;"	f
breakpoint	x86.h	/^breakpoint(void)$/;"	f
console_clear	mpos-x86.c	/^console_clear(void)$/;"	f
console_printf	lib.c	/^console_printf(uint16_t *cursor, int color, const char *format, ...)$/;"	f
console_putc	lib.c	/^console_putc(uint16_t *cursor, unsigned char c, int color)$/;"	f	file:
console_read_digit	mpos-x86.c	/^console_read_digit(void)$/;"	f
console_vprintf	lib.c	/^console_vprintf(uint16_t *cursor, int color, const char *format, va_list val)$/;"	f
copy_stack	mpos-kern.c	/^copy_stack(process_t *dest, process_t *src)$/;"	f	file:
copyseg	mpos-loader.c	/^copyseg(void *dst, const uint8_t *src, uint32_t filesz, uint32_t memsz)$/;"	f	file:
counter	mpos-app2.c	/^volatile int counter;$/;"	v
cpuid	x86.h	/^cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)$/;"	f
curoff	mkbootdisk.c	/^off_t curoff = 0;$/;"	v
current	mpos-kern.c	/^process_t *current;$/;"	v
default_int_handler	mpos-int.S	/^default_int_handler:$/;"	l
diskfd	mkbootdisk.c	/^int diskfd;$/;"	v
diskwrite	mkbootdisk.c	/^diskwrite(const void *data, size_t amt)$/;"	f
do_fork	mpos-kern.c	/^do_fork(process_t *parent)$/;"	f	file:
e_ehsize	elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf
e_elf	elf.h	/^	uint8_t e_elf[12];$/;"	m	struct:Elf
e_entry	elf.h	/^	uint32_t e_entry;$/;"	m	struct:Elf
e_flags	elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf
e_machine	elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf
e_magic	elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf
e_phentsize	elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf
e_phnum	elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf
e_phoff	elf.h	/^	uint32_t e_phoff;$/;"	m	struct:Elf
e_shentsize	elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf
e_shnum	elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf
e_shoff	elf.h	/^	uint32_t e_shoff;$/;"	m	struct:Elf
e_shstrndx	elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf
e_type	elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf
e_version	elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf
end	mpos-loader.c	/^	void *end;$/;"	m	struct:ramimage	file:
fill_numbuf	lib.c	/^fill_numbuf(char *numbuf_end, uint32_t val, int base, const char *digits,$/;"	f	file:
flag_chars	lib.c	/^static const char flag_chars[] = "#0- +";$/;"	v	file:
fopencheck	mkbootdisk.c	/^fopencheck(const char *name)$/;"	f
gatedescriptor	x86.h	/^typedef struct gatedescriptor {$/;"	s
gatedescriptor_t	x86.h	/^} gatedescriptor_t;$/;"	t	typeref:struct:gatedescriptor
gd_args	x86.h	/^	unsigned gd_args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedescriptor
gd_dpl	x86.h	/^	unsigned gd_dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedescriptor
gd_off_15_0	x86.h	/^	unsigned gd_off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedescriptor
gd_off_31_16	x86.h	/^	unsigned gd_off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedescriptor
gd_p	x86.h	/^	unsigned gd_p : 1;           \/\/ Present$/;"	m	struct:gatedescriptor
gd_rsv1	x86.h	/^	unsigned gd_rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedescriptor
gd_s	x86.h	/^	unsigned gd_s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedescriptor
gd_ss	x86.h	/^	unsigned gd_ss : 16;         \/\/ segment selector$/;"	m	struct:gatedescriptor
gd_type	x86.h	/^	unsigned gd_type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:gatedescriptor
gdt	bootstart.S	/^gdt:		SEG_NULL				# null seg$/;"	l
gdtdesc	bootstart.S	/^gdtdesc:	.word	0x17			# sizeof(gdt) - 1$/;"	l
global_descriptor_table	mpos-x86.c	/^pseudodescriptor_t global_descriptor_table = {$/;"	v
idtd_base	x86.h	/^	uint32_t idtd_base;		\/\/ Base address$/;"	m	struct:pseudodescriptor
idtd_lim	x86.h	/^	uint16_t idtd_lim;              \/\/ Limit$/;"	m	struct:pseudodescriptor
inb	x86.h	/^inb(int port)$/;"	f
inl	x86.h	/^inl(int port)$/;"	f
insb	x86.h	/^insb(int port, void *addr, int cnt)$/;"	f
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
insw	x86.h	/^insw(int port, void *addr, int cnt)$/;"	f
int16_t	types.h	/^typedef short int16_t;$/;"	t
int32_t	types.h	/^typedef long int32_t;$/;"	t
int64_t	types.h	/^typedef long long int64_t;$/;"	t
int8_t	types.h	/^typedef signed char int8_t;$/;"	t
interrupt	mpos-kern.c	/^interrupt(registers_t *reg)$/;"	f
interrupt_descriptor_table	mpos-x86.c	/^pseudodescriptor_t interrupt_descriptor_table = {$/;"	v
interrupt_descriptors	mpos-x86.c	/^static gatedescriptor_t interrupt_descriptors[256];	\/* initialized below *\/$/;"	v	file:
intptr_t	types.h	/^typedef int32_t intptr_t;$/;"	t
invlpg	x86.h	/^invlpg(void *addr)$/;"	f
inw	x86.h	/^inw(int port)$/;"	f
kernel_task_descriptor	mpos-x86.c	/^static taskstate_t kernel_task_descriptor;$/;"	v	file:
lcr0	x86.h	/^lcr0(uint32_t val)$/;"	f
lcr3	x86.h	/^lcr3(pagedirectory_t val)$/;"	f
lcr4	x86.h	/^lcr4(uint32_t val)$/;"	f
lidt	x86.h	/^lidt(void *p)$/;"	f
lldt	x86.h	/^lldt(uint16_t sel)$/;"	f
loader_panic	mpos-loader.c	/^loader_panic(void)$/;"	f	file:
lower_digits	lib.c	/^static const char lower_digits[] = "0123456789abcdef";$/;"	v	file:
ltr	x86.h	/^ltr(uint16_t sel)$/;"	f
main	mkbootdisk.c	/^main(int argc, char *argv[])$/;"	f
maxoff	mkbootdisk.c	/^off_t maxoff = 0;$/;"	v
memcpy	lib.c	/^memcpy(void *dst, const void *src, size_t n)$/;"	f
memmove	lib.c	/^memmove(void *dst, const void *src, size_t n)$/;"	f
memset	lib.c	/^memset(void *v, int c, size_t n)$/;"	f
multiboot	mpos-int.S	/^multiboot:$/;"	l
multiboot_start	mpos-int.S	/^multiboot_start:$/;"	l
off_t	types.h	/^typedef int32_t off_t;$/;"	t
offsetof	types.h	77;"	d
outb	x86.h	/^outb(int port, uint8_t data)$/;"	f
outl	x86.h	/^outl(int port, uint32_t data)$/;"	f
outsb	x86.h	/^outsb(int port, const void *addr, int cnt)$/;"	f
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outsw	x86.h	/^outsw(int port, const void *addr, int cnt)$/;"	f
outw	x86.h	/^outw(int port, uint16_t data)$/;"	f
p_align	elf.h	/^	uint32_t p_align;$/;"	m	struct:Proghdr
p_exit_status	mpos-kern.h	/^	int p_exit_status;		\/\/ Process's exit status (if it has$/;"	m	struct:process
p_filesz	elf.h	/^	uint32_t p_filesz;$/;"	m	struct:Proghdr
p_flags	elf.h	/^	uint32_t p_flags;$/;"	m	struct:Proghdr
p_memsz	elf.h	/^	uint32_t p_memsz;$/;"	m	struct:Proghdr
p_offset	elf.h	/^	uint32_t p_offset;$/;"	m	struct:Proghdr
p_pa	elf.h	/^	uint32_t p_pa;$/;"	m	struct:Proghdr
p_pid	mpos-kern.h	/^	pid_t p_pid;			\/\/ Process ID$/;"	m	struct:process
p_registers	mpos-kern.h	/^	registers_t p_registers;	\/\/ Current process state: registers,$/;"	m	struct:process
p_state	mpos-kern.h	/^	procstate_t p_state;		\/\/ Process state; see above$/;"	m	struct:process
p_type	elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr
p_va	elf.h	/^	uint32_t p_va;$/;"	m	struct:Proghdr
pagedirectory_t	types.h	/^typedef pte_t *pagedirectory_t;$/;"	t
physaddr_t	types.h	/^typedef uint32_t physaddr_t;$/;"	t
pid_t	types.h	/^typedef int32_t pid_t;$/;"	t
ppn_t	types.h	/^typedef uint32_t ppn_t;$/;"	t
proc_array	mpos-kern.c	/^static process_t proc_array[NPROCS];$/;"	v	file:
process	mpos-kern.h	/^typedef struct process {$/;"	s
process_t	mpos-kern.h	/^} process_t;$/;"	t	typeref:struct:process
procstate	mpos-kern.h	/^typedef enum procstate {$/;"	g
procstate_t	mpos-kern.h	/^} procstate_t;$/;"	t	typeref:enum:procstate
program_loader	mpos-loader.c	/^program_loader(int program_id, uint32_t *entry_point)$/;"	f
protcseg	bootstart.S	/^protcseg:	movw	$SEGSEL_BOOT_DATA, %ax	# Our data segment selector$/;"	l
pseudodescriptor	x86.h	/^struct pseudodescriptor {$/;"	s
pseudodescriptor_t	x86.h	/^typedef struct pseudodescriptor pseudodescriptor_t;$/;"	t	typeref:struct:pseudodescriptor
pte_t	types.h	/^typedef uint32_t pte_t;$/;"	t
ramimage	mpos-loader.c	/^struct ramimage {$/;"	s	file:
ramimages	mpos-loader.c	/^} ramimages[] = {$/;"	v	typeref:struct:ramimage
rcr0	x86.h	/^rcr0(void)$/;"	f
rcr2	x86.h	/^rcr2(void)$/;"	f
rcr3	x86.h	/^rcr3(void)$/;"	f
rcr4	x86.h	/^rcr4(void)$/;"	f
read_cycle_counter	x86.h	/^read_cycle_counter(void)$/;"	f
read_ebp	x86.h	/^read_ebp(void)$/;"	f
read_eflags	x86.h	/^read_eflags(void)$/;"	f
read_esp	x86.h	/^read_esp(void)$/;"	f
readdeps	mergedep.pl	/^sub readdeps {$/;"	s
readsect	mpos-boot.c	/^readsect(void *dst, uint32_t sect)$/;"	f
readseg	mpos-boot.c	/^readseg(uint32_t va, uint32_t filesz, uint32_t memsz, uint32_t sect)$/;"	f
real_to_prot	bootstart.S	/^real_to_prot:	cli			# Don't allow interrupts: mandatory,$/;"	l
reg_cs	x86.h	/^	uint16_t reg_cs;		\/\/ EIP, code segment, flags (eflags)$/;"	m	struct:registers
reg_ds	x86.h	/^	uint16_t reg_ds;$/;"	m	struct:registers
reg_eax	x86.h	/^	uint32_t reg_eax;$/;"	m	struct:registers
reg_ebp	x86.h	/^	uint32_t reg_ebp;$/;"	m	struct:registers
reg_ebx	x86.h	/^	uint32_t reg_ebx;$/;"	m	struct:registers
reg_ecx	x86.h	/^	uint32_t reg_ecx;$/;"	m	struct:registers
reg_edi	x86.h	/^	uint32_t reg_edi;		\/\/ (1) General CPU registers$/;"	m	struct:registers
reg_edx	x86.h	/^	uint32_t reg_edx;$/;"	m	struct:registers
reg_eflags	x86.h	/^	uint32_t reg_eflags;$/;"	m	struct:registers
reg_eip	x86.h	/^	uint32_t reg_eip;		\/\/ (4) Task status$/;"	m	struct:registers
reg_err	x86.h	/^	uint32_t reg_err;		\/\/ code (optional; supplied by x86$/;"	m	struct:registers
reg_es	x86.h	/^	uint16_t reg_es;		\/\/ (2) Extra segments %es and %ds$/;"	m	struct:registers
reg_esi	x86.h	/^	uint32_t reg_esi;		\/\/ order defined by 'pushal'$/;"	m	struct:registers
reg_esp	x86.h	/^	uint32_t reg_esp;		\/\/ (5) Stack registers$/;"	m	struct:registers
reg_intno	x86.h	/^	uint32_t reg_intno;		\/\/ (3) Interrupt number and error$/;"	m	struct:registers
reg_original_esp	x86.h	/^	uint32_t reg_original_esp;$/;"	m	struct:registers
reg_padding1	x86.h	/^	uint16_t reg_padding1;$/;"	m	struct:registers
reg_padding2	x86.h	/^	uint16_t reg_padding2;$/;"	m	struct:registers
reg_padding3	x86.h	/^	uint16_t reg_padding3;		\/\/ in the order required by 'iret'$/;"	m	struct:registers
reg_padding4	x86.h	/^	uint16_t reg_padding4;		\/\/ when changing privilege (e.g.$/;"	m	struct:registers
reg_ss	x86.h	/^	uint16_t reg_ss;		\/\/ in the order required by 'iret'$/;"	m	struct:registers
registers	x86.h	/^typedef struct registers {$/;"	s
registers_t	x86.h	/^} registers_t;$/;"	t	typeref:struct:registers
run	mpos-x86.c	/^run(process_t *proc)$/;"	f
run_child	mpos-app.c	/^run_child(void)$/;"	f
run_child	mpos-app2.c	/^run_child(void)$/;"	f
schedule	mpos-kern.c	/^schedule(void)$/;"	f
sd_avl	x86.h	/^	unsigned sd_avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segmentdescriptor
sd_base_15_0	x86.h	/^	unsigned sd_base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segmentdescriptor
sd_base_23_16	x86.h	/^	unsigned sd_base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segmentdescriptor
sd_base_31_24	x86.h	/^	unsigned sd_base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segmentdescriptor
sd_db	x86.h	/^	unsigned sd_db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segmentdescriptor
sd_dpl	x86.h	/^	unsigned sd_dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segmentdescriptor
sd_g	x86.h	/^	unsigned sd_g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segmentdescriptor
sd_lim_15_0	x86.h	/^	unsigned sd_lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segmentdescriptor
sd_lim_19_16	x86.h	/^	unsigned sd_lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segmentdescriptor
sd_p	x86.h	/^	unsigned sd_p : 1;          \/\/ Present$/;"	m	struct:segmentdescriptor
sd_rsv1	x86.h	/^	unsigned sd_rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segmentdescriptor
sd_s	x86.h	/^	unsigned sd_s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segmentdescriptor
sd_type	x86.h	/^	unsigned sd_type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segmentdescriptor
segmentdescriptor	x86.h	/^typedef struct segmentdescriptor {$/;"	s
segmentdescriptor_t	x86.h	/^} segmentdescriptor_t;$/;"	t	typeref:struct:segmentdescriptor
segments	mpos-x86.c	/^static segmentdescriptor_t segments[] = {$/;"	v	file:
segments_init	mpos-x86.c	/^segments_init(void)$/;"	f
sh_addr	elf.h	/^	uint32_t sh_addr;$/;"	m	struct:Secthdr
sh_addralign	elf.h	/^	uint32_t sh_addralign;$/;"	m	struct:Secthdr
sh_entsize	elf.h	/^	uint32_t sh_entsize;$/;"	m	struct:Secthdr
sh_flags	elf.h	/^	uint32_t sh_flags;$/;"	m	struct:Secthdr
sh_info	elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr
sh_link	elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr
sh_name	elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr
sh_offset	elf.h	/^	uint32_t sh_offset;$/;"	m	struct:Secthdr
sh_size	elf.h	/^	uint32_t sh_size;$/;"	m	struct:Secthdr
sh_type	elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr
size_t	types.h	/^typedef uint32_t size_t;$/;"	t
special_registers_init	mpos-x86.c	/^special_registers_init(process_t *proc)$/;"	f
spinloop	bootstart.S	/^spinloop:	jmp spinloop		# ..but in case it does, spin.$/;"	l
ssize_t	types.h	/^typedef int32_t ssize_t;$/;"	t
start	bootstart.S	/^start:		.code16				# This runs in real mode$/;"	l
start	mpos-app.c	/^start(void)$/;"	f
start	mpos-app2.c	/^start(void)$/;"	f
start	mpos-kern.c	/^start(void)$/;"	f
strlen	lib.c	/^strlen(const char *s)$/;"	f
strnlen	lib.c	/^strnlen(const char *s, size_t maxlen)$/;"	f
sys_exit	mpos-app.h	/^sys_exit(int status)$/;"	f
sys_fork	mpos-app.h	/^sys_fork(void)$/;"	f
sys_getpid	mpos-app.h	/^sys_getpid(void)$/;"	f
sys_int48_handler	mpos-int.S	/^sys_int48_handler:$/;"	l
sys_int49_handler	mpos-int.S	/^sys_int49_handler:$/;"	l
sys_int50_handler	mpos-int.S	/^sys_int50_handler:$/;"	l
sys_int51_handler	mpos-int.S	/^sys_int51_handler:$/;"	l
sys_int52_handler	mpos-int.S	/^sys_int52_handler:$/;"	l
sys_int53_handler	mpos-int.S	/^sys_int53_handler:$/;"	l
sys_int54_handler	mpos-int.S	/^sys_int54_handler:$/;"	l
sys_int55_handler	mpos-int.S	/^sys_int55_handler:$/;"	l
sys_int56_handler	mpos-int.S	/^sys_int56_handler:$/;"	l
sys_int57_handler	mpos-int.S	/^sys_int57_handler:$/;"	l
sys_int_handlers	mpos-int.S	/^sys_int_handlers:$/;"	l
sys_wait	mpos-app.h	/^sys_wait(pid_t pid)$/;"	f
sys_yield	mpos-app.h	/^sys_yield(void)$/;"	f
taskstate	x86.h	/^typedef struct taskstate {$/;"	s
taskstate_t	x86.h	/^} taskstate_t;$/;"	t	typeref:struct:taskstate
tlbflush	x86.h	/^tlbflush(void)$/;"	f
ts_cr3	x86.h	/^	physaddr_t ts_cr3;	\/\/ Page directory base$/;"	m	struct:taskstate
ts_cs	x86.h	/^	uint16_t ts_cs;$/;"	m	struct:taskstate
ts_ds	x86.h	/^	uint16_t ts_ds;$/;"	m	struct:taskstate
ts_eax	x86.h	/^	uint32_t ts_eax;	\/\/ More saved state (registers)$/;"	m	struct:taskstate
ts_ebp	x86.h	/^	uintptr_t ts_ebp;$/;"	m	struct:taskstate
ts_ebx	x86.h	/^	uint32_t ts_ebx;$/;"	m	struct:taskstate
ts_ecx	x86.h	/^	uint32_t ts_ecx;$/;"	m	struct:taskstate
ts_edi	x86.h	/^	uint32_t ts_edi;$/;"	m	struct:taskstate
ts_edx	x86.h	/^	uint32_t ts_edx;$/;"	m	struct:taskstate
ts_eflags	x86.h	/^	uint32_t ts_eflags;$/;"	m	struct:taskstate
ts_eip	x86.h	/^	uintptr_t ts_eip;	\/\/ Saved state from last task switch$/;"	m	struct:taskstate
ts_es	x86.h	/^	uint16_t ts_es;		\/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
ts_esi	x86.h	/^	uint32_t ts_esi;$/;"	m	struct:taskstate
ts_esp	x86.h	/^	uintptr_t ts_esp;$/;"	m	struct:taskstate
ts_esp0	x86.h	/^	uintptr_t ts_esp0;	\/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
ts_esp1	x86.h	/^	uintptr_t ts_esp1;$/;"	m	struct:taskstate
ts_esp2	x86.h	/^	uintptr_t ts_esp2;$/;"	m	struct:taskstate
ts_fs	x86.h	/^	uint16_t ts_fs;$/;"	m	struct:taskstate
ts_gs	x86.h	/^	uint16_t ts_gs;$/;"	m	struct:taskstate
ts_iomb	x86.h	/^	uint16_t ts_iomb;	\/\/ I\/O map base address$/;"	m	struct:taskstate
ts_ldt	x86.h	/^	uint16_t ts_ldt;$/;"	m	struct:taskstate
ts_link	x86.h	/^	uint32_t ts_link;	\/\/ Old ts selector$/;"	m	struct:taskstate
ts_padding1	x86.h	/^	uint16_t ts_padding1;$/;"	m	struct:taskstate
ts_padding10	x86.h	/^	uint16_t ts_padding10;$/;"	m	struct:taskstate
ts_padding2	x86.h	/^	uint16_t ts_padding2;$/;"	m	struct:taskstate
ts_padding3	x86.h	/^	uint16_t ts_padding3;$/;"	m	struct:taskstate
ts_padding4	x86.h	/^	uint16_t ts_padding4;$/;"	m	struct:taskstate
ts_padding5	x86.h	/^	uint16_t ts_padding5;$/;"	m	struct:taskstate
ts_padding6	x86.h	/^	uint16_t ts_padding6;$/;"	m	struct:taskstate
ts_padding7	x86.h	/^	uint16_t ts_padding7;$/;"	m	struct:taskstate
ts_padding8	x86.h	/^	uint16_t ts_padding8;$/;"	m	struct:taskstate
ts_padding9	x86.h	/^	uint16_t ts_padding9;$/;"	m	struct:taskstate
ts_ss	x86.h	/^	uint16_t ts_ss;$/;"	m	struct:taskstate
ts_ss0	x86.h	/^	uint16_t ts_ss0;	\/\/   after an increase in privilege level$/;"	m	struct:taskstate
ts_ss1	x86.h	/^	uint16_t ts_ss1;$/;"	m	struct:taskstate
ts_ss2	x86.h	/^	uint16_t ts_ss2;$/;"	m	struct:taskstate
ts_t	x86.h	/^	uint16_t ts_t;		\/\/ Trap on task switch$/;"	m	struct:taskstate
uint16_t	types.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	types.h	/^typedef unsigned long uint32_t;$/;"	t
uint64_t	types.h	/^typedef unsigned long long uint64_t;$/;"	t
uint8_t	types.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	types.h	/^typedef uint32_t uintptr_t;$/;"	t
upper_digits	lib.c	/^static const char upper_digits[] = "0123456789ABCDEF";$/;"	v	file:
usage	mkbootdisk.c	/^usage(void)$/;"	f
va_arg	lib.h	26;"	d
va_end	lib.h	28;"	d
va_list	lib.h	/^typedef char *va_list;$/;"	t
va_start	lib.h	24;"	d
waitdisk	mpos-boot.c	/^waitdisk(void)$/;"	f
write_eflags	x86.h	/^write_eflags(uint32_t eflags)$/;"	f
